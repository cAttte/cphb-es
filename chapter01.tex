\chapter{Introducción}

La programación competitiva combina dos temas:
(1) el diseño de algoritmos y (2) la implementación de algoritmos.

El \key{diseño de algoritmos} consiste en la resolución de problemas
y el pensamiento matemático.
Se necesitan habilidades para analizar problemas y resolverlos
de manera creativa.
Un algoritmo para resolver un problema
debe ser tanto correcto como eficiente,
y el núcleo del problema a menudo
trata de inventar un algoritmo eficiente.

El conocimiento teórico de los algoritmos
es importante para las personas que participan en la programación competitiva.
Típicamente, una solución a un problema es
una combinación de técnicas conocidas y
nuevos conocimientos.
Las técnicas que aparecen en la programación competitiva
también forman la base para la investigación científica
de los algoritmos.

La \key{implementación de algoritmos} requiere buenas
habilidades de programación.
En la programación competitiva, las soluciones
se califican mediante la prueba de un algoritmo implementado
usando un conjunto de casos de prueba.
Por lo tanto, no es suficiente que la idea del
algoritmo sea correcta, sino que la implementación también
debe ser correcta.

Un buen estilo de codificación en concursos es
directo y conciso.
Los programas deben escribirse rápidamente,
porque no hay mucho tiempo disponible.
A diferencia de la ingeniería de software tradicional,
los programas son cortos (generalmente como máximo unas
pocas cientos de líneas de código) y no necesitan
mantenimiento después del concurso.

\section{Lenguajes de programación}

\index{lenguaje de programación}

Actualmente, los lenguajes de programación más populares
utilizados en concursos son C++, Python y Java.
Por ejemplo, en Google Code Jam 2017,
entre los mejores 3,000 participantes,
el 79 \% utilizó C++,
el 16 \% utilizó Python y
el 8 \% utilizó Java \cite{goo17}.
Algunas personas participantes también utilizaron varios lenguajes.

Muchas personas piensan que C++ es la mejor opción
para una persona que participa en programación competitiva,
y C++ está casi siempre disponible en
sistemas de competencias.
Los beneficios de usar C++ son que
es un lenguaje muy eficiente y
su biblioteca estándar contiene una
gran colección
de estructuras de datos y algoritmos.

Por otro lado, es bueno
dominar varios lenguajes y comprender
sus fortalezas.
Por ejemplo, si se necesitan enteros grandes
en el problema,
Python puede ser una buena opción, porque
contiene operaciones integradas para
calcular con enteros grandes.
Aún así, la mayoría de los problemas en concursos de programación
están establecidos de tal manera que
usar un lenguaje de programación específico
no representa una ventaja injusta.

Todos los programas de ejemplo en este libro están escritos en C++,
y se utilizan a menudo las estructuras de datos y algoritmos
de la biblioteca estándar.
Los programas siguen el estándar C++11,
que se puede utilizar en la mayoría de los concursos en la actualidad.
Si aún no puedes programar en C++, 
ahora es un buen momento para comenzar a aprender.

\subsubsection{Plantilla de código C++}

Una plantilla típica de código C++ para programación competitiva
se ve así:

\begin{lstlisting}
#include <bits/stdc++.h>

using namespace std;

int main() {
    // aquí va la solución
}
\end{lstlisting}

La línea \texttt{\#include} al principio
del código es una característica del compilador \texttt{g++}
que nos permite incluir toda la biblioteca estándar.
Por lo tanto, no es necesario incluir por separado
bibliotecas como \texttt{iostream},
\texttt{vector} y \texttt{algorithm},
sino que están disponibles automáticamente.

La línea \texttt{using} declara
que las clases y funciones
de la biblioteca estándar se pueden utilizar directamente
en el código.
Sin la línea \texttt{using}, tendríamos
que escribir, por ejemplo, \texttt{std::cout},
pero ahora es suficiente con escribir \texttt{cout}.

El código se puede compilar utilizando el siguiente comando:

\begin{lstlisting}
g++ -std=c++11 -O2 -Wall test.cpp -o test
\end{lstlisting}

Este comando produce un archivo binario \texttt{test}
a partir del código fuente \texttt{test.cpp}.
El compilador sigue el estándar C++11
(\texttt{-std=c++11}),
optimiza el código (\texttt{-O2})
y muestra advertencias sobre posibles errores (\texttt{-Wall}).

\section{Entrada y salida}

\index{entrada y salida}

En la mayoría de los concursos, se utilizan flujos estándar
para leer la entrada y escribir la salida.
En C++, los flujos estándar son
\texttt{cin} para la entrada y \texttt{cout} para la salida.
Además, se pueden usar las funciones C
\texttt{scanf} y \texttt{printf}.

La entrada para el programa generalmente consiste en
números y cadenas que están separados por
espacios y saltos de línea.
Se pueden leer del flujo \texttt{cin}
de la siguiente manera:

\begin{lstlisting}
int a, b;
string x;
cin >> a >> b >> x;
\end{lstlisting}

Este tipo de código siempre funciona,
suponiendo que haya al menos un espacio
o salto de línea entre cada elemento en la entrada.
Por ejemplo, el código anterior puede leer
ambas entradas siguientes:
\begin{lstlisting}
123 456 mono
\end{lstlisting}
\begin{lstlisting}
123    456
mono
\end{lstlisting}
El flujo \texttt{cout} se utiliza para la salida
de la siguiente manera:
\begin{lstlisting}
int a = 123, b = 456;
string x = "mono";
cout << a << " " << b << " " << x << "\n";
\end{lstlisting}

La entrada y salida a veces
es un cuello de botella en el programa.
Las siguientes líneas al comienzo del código
hacen que la entrada y salida sean más eficientes:

\begin{lstlisting}
ios::sync_with_stdio(0);
cin.tie(0);
\end{lstlisting}

Tenga en cuenta que la línea nueva \texttt{"\textbackslash n"}
funciona más rápido que \texttt{endl},
porque \texttt{endl} siempre provoca
una operación de vaciado.

Las funciones C \texttt{scanf}
y \texttt{printf} son una alternativa
a los flujos estándar de C++.
Por lo general, son un poco más rápidas,
pero también son más difíciles de usar.
El siguiente código lee dos enteros de la entrada:
\begin{lstlisting}
int a, b;
scanf("%d %d", &a, &b);
\end{lstlisting}
El siguiente código imprime dos enteros:
\begin{lstlisting}
int a = 123, b = 456;
printf("%d %d\n", a, b);
\end{lstlisting}
A veces, el programa debe leer una línea completa
desde la entrada, posiblemente conteniendo espacios.
Esto se puede lograr utilizando la
función \texttt{getline}:

\begin{lstlisting}
string s;
getline(cin, s);
\end{lstlisting}

Si la cantidad de datos es desconocida, el siguiente
bucle es útil:
\begin{lstlisting}
while (cin >> x) {
    // código
}
\end{lstlisting}
Este bucle lee elementos de la entrada
uno tras otro, hasta que no haya
más datos disponibles en la entrada.

En algunos sistemas de competencia, se utilizan archivos para
entrada y salida.
Una solución fácil para esto es escribir
el código como de costumbre utilizando flujos estándar,
pero agregue las siguientes líneas al comienzo del código:
\begin{lstlisting}
freopen("input.txt", "r", stdin);
freopen("output.txt", "w", stdout);
\end{lstlisting}
Después de esto, el programa lee la entrada del archivo
''input.txt'' y escribe la salida en el archivo
''output.txt''.

\section{Trabajando con números}

\index{entero}

\subsubsection{Enteros}

El tipo de entero más utilizado en la programación competitiva
es \texttt{int}, que es un tipo de 32 bits con
un rango de valores de $-2^{31} \ldots 2^{31}-1$
o aproximadamente $-2 \cdot 10^9 \ldots 2 \cdot 10^9$.
Si el tipo \texttt{int} no es suficiente,
se puede utilizar el tipo de 64 bits \texttt{long long}.
Tiene un rango de valores de $-2^{63} \ldots 2^{63}-1$
o aproximadamente $-9 \cdot 10^{18} \ldots 9 \cdot 10^{18}$.

El siguiente código define una
variable \texttt{long long}:
\begin{lstlisting}
long long x = 123456789123456789LL;
\end{lstlisting}
El sufijo \texttt{LL} significa que el
tipo de número es \texttt{long long}.

Un error común al usar el tipo \texttt{long long}
es que el tipo \texttt{int} todavía se usa en alguna parte
en el código.
Por ejemplo, el siguiente código contiene
un error sutil:

\begin{lstlisting}
int a = 123456789;
long long b = a*a;
cout << b << "\n"; // -1757895751
\end{lstlisting}

Aunque la variable \texttt{b} es de tipo \texttt{long long},
ambos números en la expresión \texttt{a*a}
son de tipo \texttt{int} y el resultado es
también de tipo \texttt{int}.
Debido a esto, la variable \texttt{b} contendrá
un resultado incorrecto.
El problema se puede solucionar cambiando el tipo
de \texttt{a} a \texttt{long long} o
cambiando la expresión a \texttt{(long long)a*a}.


Por lo general, los problemas de concurso se establecen de tal manera que
el tipo \texttt{long long} es suficiente.
Aún así, es bueno saber que
el compilador \texttt{g++} también proporciona
un tipo de 128 bits \texttt{\_\_int128\_t}
con un rango de valores de
$-2^{127} \ldots 2^{127}-1$ o aproximadamente $-10^{38} \ldots 10^{38}$.
Sin embargo, este tipo no está disponible en todos los sistemas de concurso.

\subsubsection{Aritmética modular}

\index{residuo}
\index{aritmética modular}

Denotamos por $x \bmod m$ el residuo
cuando $x$ se divide por $m$.
Por ejemplo, $17 \bmod 5 = 2$,
porque $17 = 3 \cdot 5 + 2$.

A veces, la respuesta a un problema es un
número muy grande, pero es suficiente
darlo ''módulo $m$'', es decir,
el residuo cuando la respuesta se divide por $m$
(por ejemplo, ''módulo $10^9+7$'').
La idea es que incluso si la respuesta real
es muy grande,
basta con utilizar los tipos
\texttt{int} y \texttt{long long}.

Una propiedad importante del residuo es que
en suma, resta y multiplicación,
el residuo se puede tomar antes de la operación:

\[
\begin{array}{rcr}
(a+b) \bmod m & = & (a \bmod m + b \bmod m) \bmod m \\
(a-b) \bmod m & = & (a \bmod m - b \bmod m) \bmod m \\
(a \cdot b) \bmod m & = & (a \bmod m \cdot b \bmod m) \bmod m
\end{array}
\]

Así, podemos tomar el residuo después de cada operación
y los números nunca serán demasiado grandes.

Por ejemplo, el siguiente código calcula $n!$,
el factorial de $n$, módulo $m$:
\begin{lstlisting}
long long x = 1;
for (int i = 2; i <= n; i++) {
    x = (x*i)%m;
}
cout << x%m << "\n";
\end{lstlisting}

Por lo general, queremos que el residuo siempre
esté entre $0\ldots m-1$.
Sin embargo, en C++ y otros lenguajes,
el residuo de un número negativo
es cero o negativo.
Una forma fácil de asegurarse de que no haya
residuos negativos es calcular primero
el residuo como de costumbre y luego agregar $m$
si el resultado es negativo:
\begin{lstlisting}
x = x%m;
if (x < 0) x += m;
\end{lstlisting}
Sin embargo, esto solo es necesario cuando hay
restas en el código y el
residuo puede volverse negativo.

\subsubsection{Números de punto flotante}

\index{número de punto flotante}

Los tipos de punto flotante habituales en
programación competitiva son
el \texttt{double} de 64 bits
y, como una extensión en el compilador \texttt{g++},
el \texttt{long double} de 80 bits.
En la mayoría de los casos, \texttt{double} es suficiente,
pero \texttt{long double} es más preciso.

La precisión requerida de la respuesta
generalmente se proporciona en el enunciado del problema.
Una forma fácil de mostrar la respuesta es utilizar
la función \texttt{printf}
e indicar el número de decimales
en la cadena de formato.
Por ejemplo, el siguiente código imprime
el valor de $x$ con 9 decimales:

\begin{lstlisting}
printf("%.9f\n", x);
\end{lstlisting}

Una dificultad al usar números de punto flotante
es que algunos números no pueden ser representados
con precisión como números de punto flotante,
y habrá errores de redondeo.
Por ejemplo, el resultado del siguiente código
es sorprendente:

\begin{lstlisting}
double x = 0.3*3+0.1;
printf("%.20f\n", x); // 0.99999999999999988898
\end{lstlisting}

Debido a un error de redondeo,
el valor de \texttt{x} es un poco menor que 1,
mientras que el valor correcto sería 1.

Es arriesgado comparar números de punto flotante
con el operador \texttt{==},
porque es posible que los valores deban ser
iguales pero no lo son debido a errores de precisión.
Una mejor manera de comparar números de punto flotante
es suponer que dos números son iguales
si la diferencia entre ellos es menor que $\varepsilon$,
donde $\varepsilon$ es un número pequeño.

En la práctica, los números se pueden comparar
de la siguiente manera ($\varepsilon=10^{-9}$):

\begin{lstlisting}
if (abs(a-b) < 1e-9) {
    // a y b son iguales
}
\end{lstlisting}

Tenga en cuenta que, aunque los números de punto flotante son inexactos,
los enteros hasta cierto límite aún pueden ser
representados con precisión.
Por ejemplo, utilizando \texttt{double},
es posible representar con precisión todos
los enteros cuyo valor absoluto sea como máximo $2^{53}$.

\section{Acortando código}

El código corto es ideal en programación competitiva,
porque los programas deben escribirse
lo más rápido posible.
Por ello, los programadores competitivos suelen definir
nombres más cortos para los tipos de datos y otras partes del código.

\subsubsection{Nombres de tipos}
\index{tuppdef@\texttt{typedef}}
Usando el comando \texttt{typedef}
es posible dar un nombre más corto
a un tipo de dato.
Por ejemplo, el nombre \texttt{long long} es largo,
así que podemos definir un nombre más corto \texttt{ll}:
\begin{lstlisting}
typedef long long ll;
\end{lstlisting}
Después de esto, el código
\begin{lstlisting}
long long a = 123456789;
long long b = 987654321;
cout << a*b << "\n";
\end{lstlisting}
puede acortarse de la siguiente manera:
\begin{lstlisting}
ll a = 123456789;
ll b = 987654321;
cout << a*b << "\n";
\end{lstlisting}

El comando \texttt{typedef}
también se puede utilizar con tipos más complejos.
Por ejemplo, el siguiente código proporciona
el nombre \texttt{vi} para un vector de enteros
y el nombre \texttt{pi} para un par
que contiene dos enteros.
\begin{lstlisting}
typedef vector<int> vi;
typedef pair<int,int> pi;
\end{lstlisting}

\subsubsection{Macros}
\index{macro}
Otra forma de acortar el código es definir
\key{macros}.
Un macro significa que ciertas cadenas en
el código se cambiarán antes de la compilación.
En C++, los macros se definen usando la
palabra clave \texttt{\#define}.

Por ejemplo, podemos definir los siguientes macros:
\begin{lstlisting}
#define F first
#define S second
#define PB push_back
#define MP make_pair
\end{lstlisting}
Después de esto, el código
\begin{lstlisting}
v.push_back(make_pair(y1,x1));
v.push_back(make_pair(y2,x2));
int d = v[i].first+v[i].second;
\end{lstlisting}
se puede acortar de la siguiente manera:
\begin{lstlisting}
v.PB(MP(y1,x1));
v.PB(MP(y2,x2));
int d = v[i].F+v[i].S;
\end{lstlisting}

Un macro también puede tener parámetros
lo que hace posible acortar bucles y otras
estructuras.
Por ejemplo, podemos definir el siguiente macro:
\begin{lstlisting}
#define REP(i,a,b) for (int i = a; i <= b; i++)
\end{lstlisting}
Después de esto, el código
\begin{lstlisting}
for (int i = 1; i <= n; i++) {
    search(i);
}
\end{lstlisting}
se puede acortar de la siguiente manera:
\begin{lstlisting}
REP(i,1,n) {
    search(i);
}
\end{lstlisting}

A veces los macros causan errores que pueden ser difíciles
de detectar. Por ejemplo, considere el siguiente macro
que calcula el cuadrado de un número:
\begin{lstlisting}
#define SQ(a) a*a
\end{lstlisting}
Este macro \emph{no} siempre funciona como se esperaba.
Por ejemplo, el código
\begin{lstlisting}
cout << SQ(3+3) << "\n";
\end{lstlisting}
corresponde al código
\begin{lstlisting}
cout << 3+3*3+3 << "\n"; // 15
\end{lstlisting}

Una mejor versión del macro es la siguiente:
\begin{lstlisting}
#define SQ(a) (a)*(a)
\end{lstlisting}
Ahora el código
\begin{lstlisting}
cout << SQ(3+3) << "\n";
\end{lstlisting}
corresponde al código
\begin{lstlisting}
cout << (3+3)*(3+3) << "\n"; // 36
\end{lstlisting}

\section{Matemáticas}

Las matemáticas juegan un papel importante en la
programación competitiva, y no es posible convertirse
en un programador competitivo exitoso sin
tener buenas habilidades matemáticas.
Esta sección trata algunos conceptos y fórmulas
matemáticas importantes que
serán necesarios más adelante en el libro.

\subsubsection{Fórmulas de suma}

Cada suma de la forma
\[\sum_{x=1}^n x^k = 1^k+2^k+3^k+\ldots+n^k,\]
donde $k$ es un número entero positivo,
tiene una fórmula cerrada que es un
polinomio de grado $k+1$.
Por ejemplo\footnote{\index{Fórmula de Faulhaber}
Existe incluso una fórmula general para tales sumas, llamada \key{Fórmula de Faulhaber},
pero es demasiado compleja para presentarla aquí.},
\[\sum_{x=1}^n x = 1+2+3+\ldots+n = \frac{n(n+1)}{2}\]
y
\[\sum_{x=1}^n x^2 = 1^2+2^2+3^2+\ldots+n^2 = \frac{n(n+1)(2n+1)}{6}.\]

Una \key{progresión aritmética} es una \index{progresión aritmética}
secuencia de números
donde la diferencia entre dos números consecutivos
es constante.
Por ejemplo,
\[3, 7, 11, 15\]
es una progresión aritmética con constante 4.
La suma de una progresión aritmética se puede calcular
usando la fórmula
\[\underbrace{a + \cdots + b}_{n \,\, \textrm{números}} = \frac{n(a+b)}{2}\]
donde $a$ es el primer número,
$b$ es el último número y
$n$ es la cantidad de números.
Por ejemplo,
\[3+7+11+15=\frac{4 \cdot (3+15)}{2} = 36.\]
La fórmula se basa en el hecho
de que la suma consiste en $n$ números y
el valor de cada número es $(a+b)/2$ en promedio.

\index{progresión geométrica}
Una \key{progresión geométrica} es una secuencia
de números
donde la proporción entre dos números consecutivos
es constante.
Por ejemplo,
\[3,6,12,24\]
es una progresión geométrica con constante 2.
La suma de una progresión geométrica se puede calcular
usando la fórmula
\[a + ak + ak^2 + \cdots + b = \frac{bk-a}{k-1}\]
donde $a$ es el primer número,
$b$ es el último número y la
proporción entre números consecutivos es $k$.
Por ejemplo,
\[3+6+12+24=\frac{24 \cdot 2 - 3}{2-1} = 45.\]


Esta fórmula se puede derivar de la siguiente manera. Sea
\[ S = a + ak + ak^2 + \cdots + b .\]
Al multiplicar ambos lados por $k$, obtenemos
\[ kS = ak + ak^2 + ak^3 + \cdots + bk,\]
y resolviendo la ecuación
\[ kS-S = bk-a\]
se obtiene la fórmula.

Un caso especial de una suma de una progresión geométrica es la fórmula
\[1+2+4+8+\ldots+2^{n-1}=2^n-1.\]

\index{suma armónica}

Una \key{suma armónica} es una suma de la forma
\[ \sum_{x=1}^n \frac{1}{x} = 1+\frac{1}{2}+\frac{1}{3}+\ldots+\frac{1}{n}.\]

Un límite superior para una suma armónica es $\log_2(n)+1$.
Es decir, podemos
modificar cada término $1/k$ de modo que $k$ se convierta
en la potencia de dos más cercana que no exceda $k$.
Por ejemplo, cuando $n=6$, podemos estimar
la suma de la siguiente manera:
\[ 1+\frac{1}{2}+\frac{1}{3}+\frac{1}{4}+\frac{1}{5}+\frac{1}{6} \le
1+\frac{1}{2}+\frac{1}{2}+\frac{1}{4}+\frac{1}{4}+\frac{1}{4}.\]
Este límite superior consta de $\log_2(n)+1$ partes
($1$, $2 \cdot 1/2$, $4 \cdot 1/4$, etc.),
y el valor de cada parte es como máximo 1.

\subsubsection{Teoría de conjuntos}

\index{teoría de conjuntos}
\index{conjunto}
\index{intersección}
\index{unión}
\index{diferencia}
\index{subconjunto}
\index{conjunto universal}
\index{complemento}

Un \key{conjunto} es una colección de elementos.
Por ejemplo, el conjunto
\[X=\{2,4,7\}\]
contiene los elementos 2, 4 y 7.
El símbolo $\emptyset$ denota un conjunto vacío,
y $|S|$ denota el tamaño de un conjunto $S$,
es decir, la cantidad de elementos en el conjunto.
Por ejemplo, en el conjunto anterior, $|X|=3$.

Si un conjunto $S$ contiene un elemento $x$,
escribimos $x \in S$,
y de lo contrario escribimos $x \notin S$.
Por ejemplo, en el conjunto anterior
\[4 \in X \hspace{10px}\textrm{y}\hspace{10px} 5 \notin X.\]

\begin{samepage}
Se pueden construir nuevos conjuntos utilizando operaciones de conjuntos:
\begin{itemize}
\item La \key{intersección} $A \cap B$ consiste en elementos
que están tanto en $A$ como en $B$.
Por ejemplo, si $A=\{1,2,5\}$ y $B=\{2,4\}$,
entonces $A \cap B = \{2\}$.
\item La \key{unión} $A \cup B$ consiste en elementos
que están en $A$ o en $B$ o en ambos.
Por ejemplo, si $A=\{3,7\}$ y $B=\{2,3,8\}$,
entonces $A \cup B = \{2,3,7,8\}$.
\item El \key{complemento} $\bar A$ consiste en elementos
que no están en $A$.
La interpretación de un complemento depende del
\key{conjunto universal}, que contiene todos los elementos posibles.
Por ejemplo, si $A=\{1,2,5,7\}$ y el conjunto universal es
$\{1,2,\ldots,10\}$, entonces $\bar A = \{3,4,6,8,9,10\}$.
\item La \key{diferencia} $A \setminus B = A \cap \bar B$
consiste en elementos que están en $A$ pero no en $B$.
Nótese que $B$ puede contener elementos que no están en $A$.
Por ejemplo, si $A=\{2,3,7,8\}$ y $B=\{3,5,8\}$,
entonces $A \setminus B = \{2,7\}$.
\end{itemize}
\end{samepage}

Si cada elemento de $A$ también pertenece a $S$,
decimos que $A$ es un \key{subconjunto} de $S$,
denotado por $A \subset S$.
Un conjunto $S$ siempre tiene $2^{|S|}$ subconjuntos,
incluido el conjunto vacío.
Por ejemplo, los subconjuntos del conjunto $\{2,4,7\}$ son
\begin{center}
$\emptyset$,
$\{2\}$, $\{4\}$, $\{7\}$, $\{2,4\}$, $\{2,7\}$, $\{4,7\}$ y $\{2,4,7\}$.
\end{center}

Algunos conjuntos utilizados con frecuencia son
$\mathbb{N}$ (números naturales),
$\mathbb{Z}$ (enteros),
$\mathbb{Q}$ (números racionales) y
$\mathbb{R}$ (números reales).
El conjunto $\mathbb{N}$
se puede definir de dos maneras, dependiendo
de la situación:
ya sea $\mathbb{N}=\{0,1,2,\ldots\}$
o $\mathbb{N}=\{1,2,3,\ldots\}$.

También podemos construir un conjunto usando una regla de la forma
\[\{f(n) : n \in S\},\]
donde $f(n)$ es alguna función.
Este conjunto contiene todos los elementos de la forma $f(n)$,
donde $n$ es un elemento en $S$.
For example, the set
\[X=\{2n : n \in \mathbb{Z}\}\]
contains all even integers.

\subsubsection{Logic}

\index{logic}
\index{negation}
\index{conjuction}
\index{disjunction}
\index{implication}
\index{equivalence}

The value of a logical expression is either
\key{true} (1) or \key{false} (0).
The most important logical operators are
$\lnot$ (\key{negation}),
$\land$ (\key{conjunction}),
$\lor$ (\key{disjunction}),
$\Rightarrow$ (\key{implication}) and
$\Leftrightarrow$ (\key{equivalence}).
The following table shows the meanings of these operators:

\begin{center}
\begin{tabular}{rr|rrrrrrr}
$A$ & $B$ & $\lnot A$ & $\lnot B$ & $A \land B$ & $A \lor B$ & $A \Rightarrow B$ & $A \Leftrightarrow B$ \\
\hline
0 & 0 & 1 & 1 & 0 & 0 & 1 & 1 \\
0 & 1 & 1 & 0 & 0 & 1 & 1 & 0 \\
1 & 0 & 0 & 1 & 0 & 1 & 0 & 0 \\
1 & 1 & 0 & 0 & 1 & 1 & 1 & 1 \\
\end{tabular}
\end{center}

The expression $\lnot A$ has the opposite value of $A$.
The expression $A \land B$ is true if both $A$ and $B$
are true,
and the expression $A \lor B$ is true if $A$ or $B$ or both
are true.
The expression $A \Rightarrow B$ is true
if whenever $A$ is true, also $B$ is true.
The expression $A \Leftrightarrow B$ is true
if $A$ and $B$ are both true or both false.

\index{predicate}

A \key{predicate} is an expression that is true or false
depending on its parameters.
Predicates are usually denoted by capital letters.
For example, we can define a predicate $P(x)$
that is true exactly when $x$ is a prime number.
Using this definition, $P(7)$ is true but $P(8)$ is false.

\index{quantifier}

A \key{quantifier} connects a logical expression
to the elements of a set.
The most important quantifiers are
$\forall$ (\key{for all}) and $\exists$ (\key{there is}).
For example,
\[\forall x (\exists y (y < x))\]
means that for each element $x$ in the set,
there is an element $y$ in the set
such that $y$ is smaller than $x$.
This is true in the set of integers,
but false in the set of natural numbers.

Using the notation described above,
we can express many kinds of logical propositions.
For example,
\[\forall x ((x>1 \land \lnot P(x)) \Rightarrow (\exists a (\exists b (a > 1 \land b > 1 \land x = ab))))\]
means that if a number $x$ is larger than 1
and not a prime number,
then there are numbers $a$ and $b$
that are larger than $1$ and whose product is $x$.
This proposition is true in the set of integers.

\subsubsection{Functions}

The function $\lfloor x \rfloor$ rounds the number $x$
down to an integer, and the function
$\lceil x \rceil$ rounds the number $x$
up to an integer. For example,
\[ \lfloor 3/2 \rfloor = 1 \hspace{10px} \textrm{and} \hspace{10px} \lceil 3/2 \rceil = 2.\]

The functions $\min(x_1,x_2,\ldots,x_n)$
and $\max(x_1,x_2,\ldots,x_n)$
give the smallest and largest of values
$x_1,x_2,\ldots,x_n$.
For example,
\[ \min(1,2,3)=1 \hspace{10px} \textrm{and} \hspace{10px} \max(1,2,3)=3.\]

\index{factorial}

The \key{factorial} $n!$ can be defined
\[\prod_{x=1}^n x = 1 \cdot 2 \cdot 3 \cdot \ldots \cdot n\]
or recursively
\[
\begin{array}{lcl}
0! & = & 1 \\
n! & = & n \cdot (n-1)! \\
\end{array}
\]

\index{Fibonacci number}

The \key{Fibonacci numbers}
%\footnote{Fibonacci (c. 1175--1250) was an Italian mathematician.}
arise in many situations.
They can be defined recursively as follows:
\[
\begin{array}{lcl}
f(0) & = & 0 \\
f(1) & = & 1 \\
f(n) & = & f(n-1)+f(n-2) \\
\end{array}
\]
The first Fibonacci numbers are
\[0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, \ldots\]
There is also a closed-form formula
for calculating Fibonacci numbers, which is sometimes called
\index{Binet's formula} \key{Binet's formula}:
\[f(n)=\frac{(1 + \sqrt{5})^n - (1-\sqrt{5})^n}{2^n \sqrt{5}}.\]

\subsubsection{Logarithms}

\index{logarithm}

The \key{logarithm} of a number $x$
is denoted $\log_k(x)$, where $k$ is the base
of the logarithm.
According to the definition,
$\log_k(x)=a$ exactly when $k^a=x$.

A useful property of logarithms is
that $\log_k(x)$ equals the number of times
we have to divide $x$ by $k$ before we reach 
the number 1.
For example, $\log_2(32)=5$
because 5 divisions by 2 are needed:

\[32 \rightarrow 16 \rightarrow 8 \rightarrow 4 \rightarrow 2 \rightarrow 1 \]

Logarithms are often used in the analysis of
algorithms, because many efficient algorithms
halve something at each step.
Hence, we can estimate the efficiency of such algorithms
using logarithms.

The logarithm of a product is
\[\log_k(ab) = \log_k(a)+\log_k(b),\]
and consequently,
\[\log_k(x^n) = n \cdot \log_k(x).\]
In addition, the logarithm of a quotient is
\[\log_k\Big(\frac{a}{b}\Big) = \log_k(a)-\log_k(b).\]
Another useful formula is
\[\log_u(x) = \frac{\log_k(x)}{\log_k(u)},\]
and using this, it is possible to calculate
logarithms to any base if there is a way to
calculate logarithms to some fixed base.

\index{natural logarithm}

The \key{natural logarithm} $\ln(x)$ of a number $x$
is a logarithm whose base is $e \approx 2.71828$.
Another property of logarithms is that
the number of digits of an integer $x$ in base $b$ is
$\lfloor \log_b(x)+1 \rfloor$.
For example, the representation of
$123$ in base $2$ is 1111011 and
$\lfloor \log_2(123)+1 \rfloor = 7$.

\section{Contests and resources}

\subsubsection{IOI}

The International Olympiad in Informatics (IOI)
is an annual programming contest for
secondary school students.
Each country is allowed to send a team of
four students to the contest.
There are usually about 300 participants
from 80 countries.

The IOI consists of two five-hour long contests.
In both contests, the participants are asked to
solve three algorithm tasks of various difficulty.
The tasks are divided into subtasks,
each of which has an assigned score.
Even if the contestants are divided into teams,
they compete as individuals.

The IOI syllabus \cite{iois} regulates the topics
that may appear in IOI tasks.
Almost all the topics in the IOI syllabus
are covered by this book.

Participants for the IOI are selected through
national contests.
Before the IOI, many regional contests are organized,
such as the Baltic Olympiad in Informatics (BOI),
the Central European Olympiad in Informatics (CEOI)
and the Asia-Pacific Informatics Olympiad (APIO).

Some countries organize online practice contests
for future IOI participants,
such as the Croatian Open Competition in Informatics \cite{coci}
and the USA Computing Olympiad \cite{usaco}.
In addition, a large collection of problems from Polish contests
is available online \cite{main}.

\subsubsection{ICPC}

The International Collegiate Programming Contest (ICPC)
is an annual programming contest for university students.
Each team in the contest consists of three students,
and unlike in the IOI, the students work together;
there is only one computer available for each team.

The ICPC consists of several stages, and finally the
best teams are invited to the World Finals.
While there are tens of thousands of participants
in the contest, there are only a small number\footnote{The exact number of final
slots varies from year to year; in 2017, there were 133 final slots.} of final slots available,
so even advancing to the finals
is a great achievement in some regions.

In each ICPC contest, the teams have five hours of time to
solve about ten algorithm problems.
A solution to a problem is accepted only if it solves
all test cases efficiently.
During the contest, competitors may view the results of other teams,
but for the last hour the scoreboard is frozen and it
is not possible to see the results of the last submissions.

The topics that may appear at the ICPC are not so well
specified as those at the IOI.
In any case, it is clear that more knowledge is needed
at the ICPC, especially more mathematical skills.

\subsubsection{Online contests}

There are also many online contests that are open for everybody.
At the moment, the most active contest site is Codeforces,
which organizes contests about weekly.
In Codeforces, participants are divided into two divisions:
beginners compete in Div2 and more experienced programmers in Div1.
Other contest sites include AtCoder, CS Academy, HackerRank and Topcoder.

Some companies organize online contests with onsite finals.
Examples of such contests are Facebook Hacker Cup,
Google Code Jam and Yandex.Algorithm.
Of course, companies also use those contests for recruiting:
performing well in a contest is a good way to prove one's skills.

\subsubsection{Books}

There are already some books (besides this book) that
focus on competitive programming and algorithmic problem solving:

\begin{itemize}
\item S. S. Skiena and M. A. Revilla:
\emph{Programming Challenges: The Programming Contest Training Manual} \cite{ski03}
\item S. Halim and F. Halim:
\emph{Competitive Programming 3: The New Lower Bound of Programming Contests} \cite{hal13}
\item K. Diks et al.: \emph{Looking for a Challenge? The Ultimate Problem Set from
the University of Warsaw Programming Competitions} \cite{dik12}
\end{itemize}

The first two books are intended for beginners,
whereas the last book contains advanced material.

Of course, general algorithm books are also suitable for
competitive programmers.
Some popular books are:

\begin{itemize}
\item T. H. Cormen, C. E. Leiserson, R. L. Rivest and C. Stein:
\emph{Introduction to Algorithms} \cite{cor09}
\item J. Kleinberg and É. Tardos:
\emph{Algorithm Design} \cite{kle05}
\item S. S. Skiena:
\emph{The Algorithm Design Manual} \cite{ski08}
\end{itemize}
