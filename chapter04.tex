\chapter{Estructuras de datos}

\index{estructura de datos}

Una \key{estructura de datos} es una forma de almacenar
datos en la memoria de una computadora.
Es importante elegir una estructura de datos adecuada
para un problema,
ya que cada estructura de datos tiene sus propias
ventajas y desventajas.
La pregunta crucial es: ¿qué operaciones
son eficientes en la estructura de datos elegida?

Este capítulo presenta las estructuras de datos más importantes
de la biblioteca estándar de C++.
Es una buena idea utilizar la biblioteca estándar
siempre que sea posible,
porque ahorrará mucho tiempo.
Más adelante en el libro, aprenderemos sobre estructuras de datos más sofisticadas
que no están disponibles
en la biblioteca estándar.

\section{Arreglos dinámicos}

\index{arreglo dinámico}
\index{vector}

Un \key{arreglo dinámico} es un arreglo cuyo
tamaño puede cambiar durante la ejecución
del programa.
El arreglo dinámico más popular en C++ es
la estructura \texttt{vector},
que se puede utilizar casi como un arreglo ordinario.

El siguiente código crea un vector vacío y
añade tres elementos a él:

\begin{lstlisting}
vector<int> v;
v.push_back(3); // [3]
v.push_back(2); // [3,2]
v.push_back(5); // [3,2,5]
\end{lstlisting}

Después de esto, los elementos se pueden acceder como en un arreglo ordinario:

\begin{lstlisting}
cout << v[0] << "\n"; // 3
cout << v[1] << "\n"; // 2
cout << v[2] << "\n"; // 5
\end{lstlisting}

La función \texttt{size} devuelve el número de elementos en el vector.
El siguiente código itera a través
del vector e imprime todos los elementos en él:

\begin{lstlisting}
for (int i = 0; i < v.size(); i++) {
    cout << v[i] << "\n";
}
\end{lstlisting}

\begin{samepage}
Una forma más corta de iterar a través de un vector es la siguiente:

\begin{lstlisting}
for (auto x : v) {
    cout << x << "\n";
}
\end{lstlisting}
\end{samepage}

La función \texttt{back} devuelve el último elemento
en el vector, y
la función \texttt{pop\_back} elimina el último elemento:

\begin{lstlisting}
vector<int> v;
v.push_back(5);
v.push_back(2);
cout << v.back() << "\n"; // 2
v.pop_back();
cout << v.back() << "\n"; // 5
\end{lstlisting}

El siguiente código crea un vector con cinco elementos:

\begin{lstlisting}
vector<int> v = {2,4,2,5,1};
\end{lstlisting}

Otra forma de crear un vector es proporcionar el número
de elementos y el valor inicial para cada elemento:

\begin{lstlisting}
// tamaño 10, valor inicial 0
vector<int> v(10);
\end{lstlisting}
\begin{lstlisting}
// tamaño 10, valor inicial 5
vector<int> v(10, 5);
\end{lstlisting}

La implementación interna de un vector
utiliza un arreglo ordinario.
Si el tamaño del vector aumenta y
el arreglo se vuelve demasiado pequeño,
se asigna un nuevo arreglo y todos los
elementos se mueven al nuevo arreglo.
Sin embargo, esto no sucede a menudo y la
complejidad de tiempo promedio de
\texttt{push\_back} es $O(1)$.

\index{string}

La estructura \texttt{string} también es un arreglo dinámico que
puede ser utilizado casi como un vector.
Además, existe una sintaxis especial para las cadenas
que no está disponible en otras estructuras de datos.
Las cadenas se pueden combinar utilizando el símbolo \texttt{+}.
La función $\texttt{substr}(k,x)$ devuelve la subcadena
que comienza en la posición $k$ y tiene una longitud de $x$,
y la función $\texttt{find}(\texttt{t})$ encuentra la posición
de la primera aparición de una subcadena \texttt{t}.

El siguiente código presenta algunas operaciones de cadenas:

\begin{lstlisting}
string a = "hatti";
string b = a+a;
cout << b << "\n"; // hattihatti
b[5] = 'v';
cout << b << "\n"; // hattivatti
string c = b.substr(3,4);
cout << c << "\n"; // tiva
\end{lstlisting}

\section{Estructuras de conjuntos}

\index{set}

Un \key{conjunto} es una estructura de datos que
mantiene una colección de elementos.
Las operaciones básicas de los conjuntos son la inserción
de elementos, búsqueda y eliminación.

La biblioteca estándar de C++ contiene dos implementaciones
de conjuntos:
La estructura \texttt{set} se basa en un árbol binario equilibrado
y sus operaciones funcionan en tiempo $O(\log n)$.
La estructura \texttt{unordered\_set} utiliza hashing
y sus operaciones funcionan en tiempo promedio de $O(1)$.

La elección de qué implementación de conjunto utilizar
a menudo es una cuestión de preferencia.
El beneficio de la estructura \texttt{set} es que mantiene
el orden de los elementos y proporciona funciones que
no están disponibles en \texttt{unordered\_set}.
Por otro lado, \texttt{unordered\_set}
puede ser más eficiente.

El siguiente código crea un conjunto
que contiene enteros,
y muestra algunas de las operaciones.
La función \texttt{insert} agrega un elemento al conjunto,
la función \texttt{count} devuelve el número de ocurrencias
de un elemento en el conjunto,
y la función \texttt{erase} elimina un elemento del conjunto.

\begin{lstlisting}
set<int> s;
s.insert(3);
s.insert(2);
s.insert(5);
cout << s.count(3) << "\n"; // 1
cout << s.count(4) << "\n"; // 0
s.erase(3);
s.insert(4);
cout << s.count(3) << "\n"; // 0
cout << s.count(4) << "\n"; // 1
\end{lstlisting}

Un conjunto se puede utilizar principalmente como un vector,
pero no es posible acceder
a los elementos utilizando la notación \texttt{[]}.
El siguiente código crea un conjunto,
imprime el número de elementos en él y luego
itera a través de todos los elementos:
\begin{lstlisting}
set<int> s = {2,5,6,8};
cout << s.size() << "\n"; // 4
for (auto x : s) {
    cout << x << "\n";
}
\end{lstlisting}

Una propiedad importante de los conjuntos es
que todos sus elementos son \emph{distintos}.
Por lo tanto, la función \texttt{count} siempre devuelve
0 (el elemento no está en el conjunto)
o 1 (el elemento está en el conjunto),
y la función \texttt{insert} nunca agrega
un elemento al conjunto si ya está
presente.
El siguiente código ilustra esto:

\begin{lstlisting}
set<int> s;
s.insert(5);
s.insert(5);
s.insert(5);
cout << s.count(5) << "\n"; // 1
\end{lstlisting}

C++ también contiene las estructuras
\texttt{multiset} y \texttt{unordered\_multiset}
que funcionan de manera similar a \texttt{set}
y \texttt{unordered\_set}
pero pueden contener múltiples instancias de un elemento.
Por ejemplo, en el siguiente código, se agregan las tres instancias
del número 5 a un multiset:

\begin{lstlisting}
multiset<int> s;
s.insert(5);
s.insert(5);
s.insert(5);
cout << s.count(5) << "\n"; // 3
\end{lstlisting}
La función \texttt{erase} elimina
todas las instancias de un elemento
de un multiset:
\begin{lstlisting}
s.erase(5);
cout << s.count(5) << "\n"; // 0
\end{lstlisting}
A menudo, solo se debe eliminar una instancia,
lo cual se puede hacer de la siguiente manera:
\begin{lstlisting}
s.erase(s.find(5));
cout << s.count(5) << "\n"; // 2
\end{lstlisting}

\section{Estructuras de mapas}

\index{mapa}

Un \key{mapa} es un arreglo generalizado
que consiste en pares clave-valor.
Mientras que las claves en un arreglo ordinario son siempre
los enteros consecutivos $0,1,\ldots,n-1$,
donde $n$ es el tamaño del arreglo,
las claves en un mapa pueden ser de cualquier tipo de dato y
no tienen que ser valores consecutivos.

La biblioteca estándar de C++ contiene dos implementaciones de mapas
que corresponden a las implementaciones de conjuntos: la estructura
\texttt{map} se basa en un árbol binario equilibrado y acceder a los elementos
toma un tiempo de $O(\log n)$,
mientras que la estructura
\texttt{unordered\_map} utiliza hashing
y acceder a los elementos toma un tiempo de $O(1)$ en promedio.

El siguiente código crea un mapa
donde las claves son cadenas y los valores son enteros:

\begin{lstlisting}
map<string,int> m;
m["mono"] = 4;
m["banana"] = 3;
m["clavecin"] = 9;
cout << m["banana"] << "\n"; // 3
\end{lstlisting}

Si se solicita el valor de una clave
pero el mapa no la contiene,
la clave se añade automáticamente al mapa con
un valor predeterminado.
Por ejemplo, en el siguiente código,
la clave ''aybabtu'' con valor 0
se añade al mapa.

\begin{lstlisting}
map<string,int> m;
cout << m["aybabtu"] << "\n"; // 0
\end{lstlisting}
La función \texttt{count} verifica
si una clave existe en un mapa:
\begin{lstlisting}
if (m.count("aybabtu")) {
    // la clave existe
}
\end{lstlisting}
El siguiente código imprime todas las claves y valores
en un mapa:
\begin{lstlisting}
for (auto x : m) {
    cout << x.first << " " << x.second << "\n";
}
\end{lstlisting}

\section{Iteradores y rangos}

\index{iterador}

Muchas funciones en la biblioteca estándar de C++
operan con iteradores.
Un \key{iterador} es una variable que apunta
a un elemento en una estructura de datos.

Los iteradores a menudo utilizados \texttt{begin}
y \texttt{end} definen un rango que contiene
todos los elementos en una estructura de datos.
El iterador \texttt{begin} apunta al
primer elemento en la estructura de datos,
y el iterador \texttt{end} apunta a
la posición \emph{después} del último elemento.
La situación se ve de la siguiente manera:

\begin{center}
\begin{tabular}{llllllllll}
\{ & 3, & 4, & 6, & 8, & 12, & 13, & 14, & 17 & \} \\
& $\uparrow$ & & & & & & & & $\uparrow$ \\
& \multicolumn{3}{l}{\texttt{s.begin()}} & & & & & & \texttt{s.end()} \\
\end{tabular}
\end{center}

Tome nota de la asimetría en los iteradores:
\texttt{s.begin()} apunta a un elemento en la estructura de datos,
mientras que \texttt{s.end()} apunta fuera de la estructura de datos.
Por lo tanto, el rango definido por los iteradores es \emph{semiabierto}.

\subsubsection{Trabajando con rangos}

Los iteradores se utilizan en funciones de la biblioteca estándar de C++
que reciben un rango de elementos en una estructura de datos.
Por lo general, queremos procesar todos los elementos en una
estructura de datos, por lo que los iteradores
\texttt{begin} y \texttt{end} se proporcionan para la función.

Por ejemplo, el siguiente código ordena un vector
usando la función \texttt{sort},
luego invierte el orden de los elementos usando la función
\texttt{reverse}, y finalmente mezcla el orden de
los elementos usando la función \texttt{random\_shuffle}.

\index{sort@\texttt{sort}}
\index{reverse@\texttt{reverse}}
\index{random\_shuffle@\texttt{random\_shuffle}}

\begin{lstlisting}
sort(v.begin(), v.end());
reverse(v.begin(), v.end());
random_shuffle(v.begin(), v.end());
\end{lstlisting}

Estas funciones también se pueden utilizar con una matriz ordinaria.
En este caso, las funciones reciben punteros a la matriz
en lugar de iteradores:

\newpage
\begin{lstlisting}
sort(a, a+n);
reverse(a, a+n);
random_shuffle(a, a+n);
\end{lstlisting}

\subsubsection{Iteradores de conjuntos}

Los iteradores se utilizan a menudo para acceder
a elementos de un conjunto.
El siguiente código crea un iterador
\texttt{it} que apunta al elemento más pequeño de un conjunto:
\begin{lstlisting}
set<int>::iterator it = s.begin();
\end{lstlisting}
Una forma más corta de escribir el código es la siguiente:
\begin{lstlisting}
auto it = s.begin();
\end{lstlisting}
El elemento al que apunta un iterador
se puede acceder utilizando el símbolo \texttt{*}.
Por ejemplo, el siguiente código imprime
el primer elemento del conjunto:

\begin{lstlisting}
auto it = s.begin();
cout << *it << "\n";
\end{lstlisting}

Los iteradores se pueden mover utilizando los operadores
\texttt{++} (hacia adelante) y \texttt{--} (hacia atrás),
lo que significa que el iterador se mueve al siguiente
o al elemento anterior en el conjunto.

El siguiente código imprime todos los elementos
en orden creciente:
\begin{lstlisting}
for (auto it = s.begin(); it != s.end(); it++) {
    cout << *it << "\n";
}
\end{lstlisting}
El siguiente código imprime el elemento más grande del conjunto:
\begin{lstlisting}
auto it = s.end(); it--;
cout << *it << "\n";
\end{lstlisting}

The function $\texttt{find}(x)$ returns an iterator
that points to an element whose value is $x$.
However, if the set does not contain $x$,
the iterator will be \texttt{end}.

\begin{lstlisting}
auto it = s.find(x);
if (it == s.end()) {
    // x is not found
}
\end{lstlisting}

The function $\texttt{lower\_bound}(x)$ returns
an iterator to the smallest element in the set
whose value is \emph{at least} $x$, and
the function $\texttt{upper\_bound}(x)$
returns an iterator to the smallest element in the set
whose value is \emph{larger than} $x$.
In both functions, if such an element does not exist,
the return value is \texttt{end}.
These functions are not supported by the
\texttt{unordered\_set} structure which
does not maintain the order of the elements.

\begin{samepage}
For example, the following code finds the element
nearest to $x$:

\begin{lstlisting}
auto it = s.lower_bound(x);
if (it == s.begin()) {
    cout << *it << "\n";
} else if (it == s.end()) {
    it--;
    cout << *it << "\n";
} else {
    int a = *it; it--;
    int b = *it;
    if (x-b < a-x) cout << b << "\n";
    else cout << a << "\n";
}
\end{lstlisting}

The code assumes that the set is not empty,
and goes through all possible cases
using an iterator \texttt{it}.
First, the iterator points to the smallest
element whose value is at least $x$.
If \texttt{it} equals \texttt{begin},
the corresponding element is nearest to $x$.
If \texttt{it} equals \texttt{end},
the largest element in the set is nearest to $x$.
If none of the previous cases hold,
the element nearest to $x$ is either the
element that corresponds to \texttt{it} or the previous element.
\end{samepage}

\section{Other structures}

\subsubsection{Bitset}

\index{bitset}

A \key{bitset} is an array
whose each value is either 0 or 1.
For example, the following code creates
a bitset that contains 10 elements:
\begin{lstlisting}
bitset<10> s;
s[1] = 1;
s[3] = 1;
s[4] = 1;
s[7] = 1;
cout << s[4] << "\n"; // 1
cout << s[5] << "\n"; // 0
\end{lstlisting}

The benefit of using bitsets is that
they require less memory than ordinary arrays,
because each element in a bitset only
uses one bit of memory.
For example, 
if $n$ bits are stored in an \texttt{int} array,
$32n$ bits of memory will be used,
but a corresponding bitset only requires $n$ bits of memory.
In addition, the values of a bitset
can be efficiently manipulated using
bit operators, which makes it possible to
optimize algorithms using bit sets.

The following code shows another way to create the above bitset:
\begin{lstlisting}
bitset<10> s(string("0010011010")); // from right to left
cout << s[4] << "\n"; // 1
cout << s[5] << "\n"; // 0
\end{lstlisting}

The function \texttt{count} returns the number
of ones in the bitset:

\begin{lstlisting}
bitset<10> s(string("0010011010"));
cout << s.count() << "\n"; // 4
\end{lstlisting}

The following code shows examples of using bit operations:
\begin{lstlisting}
bitset<10> a(string("0010110110"));
bitset<10> b(string("1011011000"));
cout << (a&b) << "\n"; // 0010010000
cout << (a|b) << "\n"; // 1011111110
cout << (a^b) << "\n"; // 1001101110
\end{lstlisting}

\subsubsection{Deque}

\index{deque}

A \key{deque} is a dynamic array
whose size can be efficiently
changed at both ends of the array.
Like a vector, a deque provides the functions
\texttt{push\_back} and \texttt{pop\_back}, but
it also includes the functions
\texttt{push\_front} and \texttt{pop\_front}
which are not available in a vector.

A deque can be used as follows:
\begin{lstlisting}
deque<int> d;
d.push_back(5); // [5]
d.push_back(2); // [5,2]
d.push_front(3); // [3,5,2]
d.pop_back(); // [3,5]
d.pop_front(); // [5]
\end{lstlisting}

The internal implementation of a deque
is more complex than that of a vector,
and for this reason, a deque is slower than a vector.
Still, both adding and removing
elements take $O(1)$ time on average at both ends.

\subsubsection{Stack}

\index{stack}

A \key{stack}
is a data structure that provides two
$O(1)$ time operations:
adding an element to the top,
and removing an element from the top.
It is only possible to access the top
element of a stack.

The following code shows how a stack can be used:
\begin{lstlisting}
stack<int> s;
s.push(3);
s.push(2);
s.push(5);
cout << s.top(); // 5
s.pop();
cout << s.top(); // 2
\end{lstlisting}
\subsubsection{Queue}

\index{queue}

A \key{queue} also
provides two $O(1)$ time operations:
adding an element to the end of the queue,
and removing the first element in the queue.
It is only possible to access the first
and last element of a queue.

The following code shows how a queue can be used:
\begin{lstlisting}
queue<int> q;
q.push(3);
q.push(2);
q.push(5);
cout << q.front(); // 3
q.pop();
cout << q.front(); // 2
\end{lstlisting}

\subsubsection{Priority queue}

\index{priority queue}
\index{heap}

A \key{priority queue}
maintains a set of elements.
The supported operations are insertion and,
depending on the type of the queue,
retrieval and removal of
either the minimum or maximum element.
Insertion and removal take $O(\log n)$ time,
and retrieval takes $O(1)$ time.

While an ordered set efficiently supports
all the operations of a priority queue,
the benefit of using a priority queue is
that it has smaller constant factors.
A priority queue is usually implemented using
a heap structure that is much simpler than a
balanced binary tree used in an ordered set.

\begin{samepage}
By default, the elements in a C++
priority queue are sorted in decreasing order,
and it is possible to find and remove the
largest element in the queue.
The following code illustrates this:

\begin{lstlisting}
priority_queue<int> q;
q.push(3);
q.push(5);
q.push(7);
q.push(2);
cout << q.top() << "\n"; // 7
q.pop();
cout << q.top() << "\n"; // 5
q.pop();
q.push(6);
cout << q.top() << "\n"; // 6
q.pop();
\end{lstlisting}
\end{samepage}

If we want to create a priority queue
that supports finding and removing
the smallest element,
we can do it as follows:

\begin{lstlisting}
priority_queue<int,vector<int>,greater<int>> q;
\end{lstlisting}

\subsubsection{Policy-based data structures}

The \texttt{g++} compiler also supports
some data structures that are not part
of the C++ standard library.
Such structures are called \emph{policy-based}
data structures.
To use these structures, the following lines
must be added to the code:
\begin{lstlisting}
#include <ext/pb_ds/assoc_container.hpp>
using namespace __gnu_pbds; 
\end{lstlisting}
After this, we can define a data structure \texttt{indexed\_set} that
is like \texttt{set} but can be indexed like an array.
The definition for \texttt{int} values is as follows:
\begin{lstlisting}
typedef tree<int,null_type,less<int>,rb_tree_tag,
             tree_order_statistics_node_update> indexed_set; 
\end{lstlisting}
Now we can create a set as follows:
\begin{lstlisting}
indexed_set s;
s.insert(2);
s.insert(3);
s.insert(7);
s.insert(9);
\end{lstlisting}
The speciality of this set is that we have access to
the indices that the elements would have in a sorted array.
The function $\texttt{find\_by\_order}$ returns
an iterator to the element at a given position:
\begin{lstlisting}
auto x = s.find_by_order(2);
cout << *x << "\n"; // 7
\end{lstlisting}
And the function $\texttt{order\_of\_key}$
returns the position of a given element:
\begin{lstlisting}
cout << s.order_of_key(7) << "\n"; // 2
\end{lstlisting}
If the element does not appear in the set,
we get the position that the element would have
in the set:
\begin{lstlisting}
cout << s.order_of_key(6) << "\n"; // 2
cout << s.order_of_key(8) << "\n"; // 3
\end{lstlisting}
Both the functions work in logarithmic time.

\section{Comparison to sorting}

It is often possible to solve a problem
using either data structures or sorting.
Sometimes there are remarkable differences
in the actual efficiency of these approaches,
which may be hidden in their time complexities.

Let us consider a problem where
we are given two lists $A$ and $B$
that both contain $n$ elements.
Our task is to calculate the number of elements
that belong to both of the lists.
For example, for the lists
\[A = [5,2,8,9] \hspace{10px} \textrm{and} \hspace{10px} B = [3,2,9,5],\]
the answer is 3 because the numbers 2, 5
and 9 belong to both of the lists.

A straightforward solution to the problem is
to go through all pairs of elements in $O(n^2)$ time,
but next we will focus on
more efficient algorithms.

\subsubsection{Algorithm 1}

We construct a set of the elements that appear in $A$,
and after this, we iterate through the elements
of $B$ and check for each elements if it
also belongs to $A$.
This is efficient because the elements of $A$
are in a set.
Using the \texttt{set} structure,
the time complexity of the algorithm is $O(n \log n)$.

\subsubsection{Algorithm 2}

It is not necessary to maintain an ordered set,
so instead of the \texttt{set} structure
we can also use the \texttt{unordered\_set} structure.
This is an easy way to make the algorithm
more efficient, because we only have to change
the underlying data structure.
The time complexity of the new algorithm is $O(n)$.

\subsubsection{Algorithm 3}

Instead of data structures, we can use sorting.
First, we sort both lists $A$ and $B$.
After this, we iterate through both the lists
at the same time and find the common elements.
The time complexity of sorting is $O(n \log n)$,
and the rest of the algorithm works in $O(n)$ time,
so the total time complexity is $O(n \log n)$.

\subsubsection{Efficiency comparison}

The following table shows how efficient
the above algorithms are when $n$ varies and
the elements of the lists are random
integers between $1 \ldots 10^9$:

\begin{center}
\begin{tabular}{rrrr}
$n$ & Algorithm 1 & Algorithm 2 & Algorithm 3 \\
\hline
$10^6$ & $1.5$ s & $0.3$ s & $0.2$ s \\
$2 \cdot 10^6$ & $3.7$ s & $0.8$ s & $0.3$ s \\
$3 \cdot 10^6$ & $5.7$ s & $1.3$ s & $0.5$ s \\
$4 \cdot 10^6$ & $7.7$ s & $1.7$ s & $0.7$ s \\
$5 \cdot 10^6$ & $10.0$ s & $2.3$ s & $0.9$ s \\
\end{tabular}
\end{center}

Algorithms 1 and 2 are equal except that
they use different set structures.
In this problem, this choice has an important effect on
the running time, because Algorithm 2
is 4–5 times faster than Algorithm 1.

However, the most efficient algorithm is Algorithm 3
which uses sorting.
It only uses half the time compared to Algorithm 2.
Interestingly, the time complexity of both
Algorithm 1 and Algorithm 3 is $O(n \log n)$,
but despite this, Algorithm 3 is ten times faster.
This can be explained by the fact that
sorting is a simple procedure and it is done
only once at the beginning of Algorithm 3,
and the rest of the algorithm works in linear time.
On the other hand,
Algorithm 1 maintains a complex balanced binary tree
during the whole algorithm.
